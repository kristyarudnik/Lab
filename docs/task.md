# Лабораторная работа №3

## Диаграмма компонентов

![image](https://github.com/kristyarudnik/Lab/assets/102550294/69b98895-6c4e-4eca-996b-92a526063435)

Из данной диаграммы используется следующая часть(компонет) "API работы с данными отеля" и "Модуль бронирования".

## Диаграмма последовательностей

![image](https://github.com/kristyarudnik/Lab/assets/102550294/c5caa8bd-3c02-4cb4-9671-6cbfd585efc3)

Диаграмма последовательности для прецедентов "Просмотр списков номеров", "Просмотр информации о номере", "Бронирование номера". 

## Модель БД

![image](https://github.com/kristyarudnik/Lab/assets/102550294/2f66e089-6800-4d8a-84d7-909006efdec0)

Модель данных имеет 5 основных сущностей: Отель, Комната, Уборка, Пользователь и бронирование.

## Применение основных принципов разработки

### KISS

- Каждый компонент и хук отвечают за свою конкретную задачу.
- Главный компонент (BookingForm.tsx) использует мелкие компоненты и хуки для упрощения структуры.

### YAGNI

- Используются только те компоненты и хуки, которые необходимы для выполнения функциональности бронирования.

### DRY

- Логика работы с формой, обработки запросов и обновления состояния вынесены в отдельные хуки, чтобы избежать дублирования кода.

### SOLID

Для каждого принципа написан отдельный код в __**src/server**__,  в угоду наглядности, постфикс в названии означает принадлежность к принципу (например name_srp.go).

#### Принцип единственной ответственности (SRP)

В представленном коде, каждый из интерфейсов (`RoomAvailabilityChecker, RoomReserver, BookingRepository`) и их соответствующие реализации имеют четко определенную ответственность. Каждый из этих интерфейсов и их реализации имеют свою специфическую ответственность. Например, `RoomAvailabilityChecker` отвечает за проверку доступности номера, RoomReserver за бронирование номера, `BookingRepository` за сохранение данных о бронировании.

BookingService: Этот класс служит координатором работы других классов и несет общую ответственность за сервис бронирования. Он не содержит деталей реализации, а лишь делегирует задачи соответствующим интерфейсам.

#### Принцип открытости/закрытости (OCP)

В представленном коде, принцип открытости/закрытости реализуется через создание новых реализаций интерфейсов для добавления нового функционала. Например, `BookingRepository` это интерфейс, который служит основой для всех репозиториев сохранения данных о бронировании

`SQLBookingRepository` - класс представляет новую реализацию интерфейса BookingRepository с использованием SQL-базы данных. Добавлением нового функционала в виде поддержки SQL-базы данных мы не изменяем существующий код, а расширяем систему, добавляя новые классы, но не трогаем то, что уже существует.

#### Принцип подстановки Барбары Лисков (LSP)

`BookingRepositoryRead` - это интерфейс, который отвечает только за чтение данных о бронировании.

`InMemoryBookingRepository` - это класс, который представляет реализацию интерфейса `BookingRepositoryRead`. Это подкласс, который должен быть заменяем базовым классом `BookingRepositoryRead`.

Если где-то в коде ожидается объект типа `BookingRepositoryRead`, мы можем безопасно использовать объект типа `InMemoryBookingRepository`, соблюдая принцип подстановки Барбары Лисков.

#### Принцип разделения интерфейса (ISP)

`RoomAvailabilityChecker, RoomReserver, BookingRepository`: Каждый из этих интерфейсов имеет свою специфичную функциональность, и класс `BookingService` зависит только от тех интерфейсов, которые ему действительно необходимы. Таким образом, клиенты `BookingService` не зависят от методов, которые им не нужны, соблюдая принцип разделения интерфейса.

#### Принцип инверсии зависимостей (DIP)

`RoomAvailabilityChecker, RoomReserver, BookingRepository`: Эти интерфейсы представляют абстракции, от которых зависит `BookingService`.

Класс `BookingService` зависит от абстракций (интерфейсов) и не привязан к конкретным реализациям. Это позволяет легко подменять конкретные реализации, не затрагивая код высокоуровневого модуля.

`NewBookingService` - это конструктор, который принимает абстракции в качестве параметров, позволяя клиентам создавать экземпляры `BookingService`, не привязываясь к конкретным реализациям.

## Дополнительные принципы разработки

### BDUF (Big Design Up Front)

BDUF предполагает, что перед началом разработки необходимо провести масштабное проектирование, подробно проработав все аспекты системы.

В контексте нашей системы, BDUF может быть нецелесообразным. Такой уровень детализации и предварительного планирования может быть избыточным и затратным по времени, так как заказчику требуется: «Пиковый сезон быстро приближается, поэтому система должна быть готова как можно скорее, иначе нам придется ждать до следующего года!»

### SoC (Separation of Concerns)

SoC предполагает разделение системы на отдельные компоненты, каждый из которых отвечает за определенную область ответственности.

Данный принцип в общем и целом уже соблюдается при проектировании архитектуры и написании кода.

### MVP (Minimum Viable Product)

MVP - это первая версия продукта, содержащая минимальный набор функций, достаточный для удовлетворения базовых потребностей пользователей.

Данный принцип важен для нас, поскольку мы стремимся как можно быстрее предоставить минимальные, но полезные функциональности для бронирования номеров. Он позволяет быстро выпустить продукт, заработать в пик сезона, получить обратную связь пользователей и последовательно добавлять новые функции.

### PoC (Proof of Concept)

PoC - это доказательство концепции, обычно небольшой итерации, направленной на проверку жизнеспособности и эффективности определенного подхода или технологии.

В нашем контексте данный принцип не совсем уместен, так как нам требуется быстро разработать MVP, а данный подход расходует время и ресурсы.
